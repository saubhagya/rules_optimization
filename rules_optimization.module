<?php
// $Id$

/**
 * @file Rules Optimization classes and classes for decision tree.
 */

/**
 * A decision tree node.
 */
class TreeNode extends RulesPlugin {

  public $left;
  public $right;
  public $data;
  public $isLeaf;

  function __construct() {
    $this->data = NULL;
    $this->left = $this->right = NULL;
    $this->isLeaf = FALSE;
  }
}

/**
 * Class implementing optimization method.
 */
class RulesOptimization extends FacesExtender implements RulesOptimizationInterface {

  /**
   * Implementation of optimize method.
   */
  public function optimize() {
    $tree = new TreeNode;
    $rules = $this->getExtendable();
    $conditions = array();
    $allCondition = array();
    foreach ($rules as $rule) {
      $newCondition = rules_and();
      if ($rule->conditions() != NULL) {
        foreach ($rule->conditions() as $condition) {
          $newCondition->condition($condition);
        }
        $newCondition = $this->convertRuleConditions($newCondition);
        $this->merge($this->arrayCopy($newCondition[0]), $allCondition);
        foreach ($newCondition as $key => $nc) {
          array_push($newCondition[$key], $rule);
        }
        $conditions = array_merge($conditions, $newCondition);
      }
    }
    if (!empty($allCondition))
      $tree = $this->insertRuleConditions($conditions, $allCondition);
    RulesLog::logger()->checkLog();
    return $tree;
  }

  /**
   * Conerts the input rule conditions to make them suitable for insertion in decision tree.
   */
  public function convertRuleConditions($condition) {
    $conditions = array(array($condition));
    $flag = 1;
    while ($flag) {
      $this->convert($conditions, $flag);
    }
    return $conditions;
  }

  /**
   * Invoked by convertRuleConditions for actual processing.
   */
  public function convert(&$conditions, &$flag) {
    $flag = 0;
    $temp = $conditions;
    $j = 0;
    foreach ($temp as $key => $condition) {
      $i = 0;
      foreach ($condition as $c) {
        if ($c instanceof RulesAND) {
          if (sizeof($c->getIterator()) == 0) {
            array_splice($conditions[$key], $i, 1);
            $flag = 1;
            return;
          }
          array_splice($conditions[$key], $i, 1, $this->convertAND($c));
          $flag = 1;
          return;
        }
        elseif ($c instanceof RulesOR) {
          if (sizeof($c->getIterator()) == 0) {
            array_splice($conditions[$key], $i, 1);
            $flag = 1;
            return;
          }
          $array = $this->convertOR($c);
          $temp2 = array();
          foreach ($array as $arr) {
            $temp1 = $conditions[$key];
            array_splice($temp1, $i, 1, $arr);
            array_push($temp2, $temp1);
          }
          array_splice($conditions, $j, 1, $temp2);
          $flag = 1;
          return;
        }
        ++$i;
      }
      ++$j;
    }
    $flag = 0;
  }

  /**
   * Converts the AND in the condition.
   */
  public function convertAND($condition) {
    if ($condition->isNegated()) {
      $temp = rules_or();
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $temp->condition($child);
      }
      return array($temp);
    }
    else {
      return $condition->getIterator();
    }
  }

  /**
   * Converts RulesOR in the condition.
   * @return
   *   Array of arrays containing conditions in OR form.
   */
  public function convertOR($condition) {
    if ($condition->isNegated()) {
      $temp = rules_and();
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $temp->condition($child);
      }
      return array(array($temp));
    }
    else {
      $temp = array();
      $array = array();
      $i = 0;
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $array[$i++] = $child;
      }
      for ($j = 0; $j < $i; $j++) {
        $temp[$j] = $this->arrayCopy($array);
        $temp[$j][$j]->isNegated()?$temp[$j][$j]->negate(FALSE):$temp[$j][$j]->negate(TRUE);
      }
    }
    return $temp;
  }

  /**
   * Inserts the converted conditions and corresponding rule in the decision tree.
   */
  public function insertRuleConditions($conditions, $allCondition) {
    $root = new TreeNode;
    $dummy = new TreeNode;
    $dummy->isLeaf = TRUE;
    $root->left = $dummy;
    foreach ($conditions as $condition) {
      $rule = end($condition);
      array_splice($condition, sizeof($condition) - 1);
      $this->sort($condition, $allCondition);
      $this->insert($root, $condition, $allCondition, $rule);
    }
    $this->traceTree($root->left, 0);
    return $root;
  }

  /**
   * Sort the input condition array as the allCondition array.
   */
  public function sort(&$condition, $allCondition) {
    $temp = array();
    $size = sizeof($allCondition);
    for ($i = 0; $i < $size; $i++) {
      $flag[$i] = 0;
    }
    for ($i = 0; $i < $size; $i++) {
      if ($flag[$i] == 0) {
        foreach ($condition as $c) {
          if ($allCondition[$i]->getElementName() == $c->getElementName()) {
            $flag[$i] = 1;
            if ($c->isNegated())
              $temp[$i] = 'RIGHT';
            else
              $temp[$i] = 'LEFT';
            break;
          }
        }
      }
    }
    for ($i = 0; $i < $size; $i++)
      if (!$flag[$i])
        $temp[$i] = 'BOTH';
    $condition = $temp;
  }

  /**
   * Invoked by insertRuleConditions to insert individual rule conditions.
   */
  public function insert(&$root, $conditions, $allCondition, $rule) {
    $temp1 = array(array(0 => 'LEFT', 1 => $root));
    $arrSize = sizeof($allCondition);
    for ($key = 0; $key < $arrSize; $key++) {
      $condition = $allCondition[$key];
      $direction = $conditions[$key];
      $temp2 = array();
      foreach ($temp1 as $arr) {
        $prevDirection = $arr[0];
        $prevNode = $arr[1];
        $n = $prevDirection == 'LEFT'?$prevNode->left:$prevNode->right;
        if ($n->data == NULL || $condition->getElementName() != $n->data->getElementName()) {
          if ($direction != 'BOTH') {
            $m = new TreeNode;
            $m->data = $condition;
            $m->left = $n;
            $o = $this->treeCopy($n);
            $m->right = $o;
            if ($prevDirection == 'LEFT') {
              $prevNode->left = $m;
            }
            else {
              $prevNode->right = $m;
            }
            array_push($temp2, array(0 => $direction, 1 => $m));
          }
          else {
            array_push($temp2, array(0 => $prevDirection, 1 => $prevNode));
          }
        }
        else {
          if ($direction == 'BOTH') {
            array_push($temp2, array(0 => 'LEFT', 1 => $n), array(0 => 'RIGHT', 1 => $n));
          }
          elseif ($direction == 'LEFT') {
            array_push($temp2, array(0 => 'LEFT', 1 => $n));
          }
          else {
            array_push($temp2, array(0 => 'RIGHT', 1 => $n));
          }
        }
      }
      $size = sizeof($temp2);
      for ($i = 0; $i < $size; $i++)
        $temp1[$i] = $temp2[$i];
    }
    foreach ($temp1 as $arr) {
      $node = $prevDirection == 'LEFT'?$arr[1]->left:$arr[1]->right;
      $this->fillRule($node, $rule);
    }
  }

  /**
   * Returns the exact copy of the input tree.
   */
  public function treeCopy($tree) {
    $root = new TreeNode;
    $root->data = $tree->data;
    if ($tree->left != NULL) {
      $root->left = $this->treeCopy($tree->left);
    }
    if ($tree->right != NULL) {
      $root->right = $this->treeCopy($tree->right);
    }
    return $root;
  }

  /**
   * Append the new conditions of input temp to allCondition.
   */
  public function merge($temp, &$allCondition) {
    $size = sizeof($allCondition);
    $temp2 = array();
    foreach ($temp as $t) {
      array_push($temp2, $t->isNegated()?$t->negate(FALSE):$t);
    }
    for ($i = 0; $i < $size; $i++) {
      $flag[$i] = 0;
    }
    foreach ($temp2 as $t) {
      $a = 0;
      for ($i = 0; $i < $size; $i++) {
        if ($flag[$i] == 0 && $allCondition[$i]->getElementName() == $t->getElementName()) {
          $flag[$i] = 1;
          $a = 1;
        }
      }
      if (!$a) {
        array_push($allCondition, $t);
      }
    }
    return $allCondition;
  }

  /**
   * Return the copy of the input array.
   */
  public function arrayCopy($array) {
    $return = array();

    $keys = array_keys($array);
    $values = array_values($array);

    for ($i = 0; $i < count($keys); $i++) {
      if (is_object($values[$i])) {
        $return[$keys[$i]] = clone $values[$i];
      }
      elseif (is_array($values[$i])) {
        $return[$keys[$i]] = arrayCopy($values[$i]);
      }
      else {
        $return[$keys[$i]] = $values[$i];
      }
    }
    return $return;
  }

  /**
   * Add the input rule at the leaves accessible by input node.
   */
  public function fillRule($node, $rule) {
    if($node->isLeaf) {
      if ($node->data == NULL) {
        $node->data = array($rule);
      }
      else {
        array_push($node->data, $rule);
      }
    }
    else {
      $this->fillRule($node->left, $rule);
      $this->fillRule($node->right, $rule);
    }
  }

  /**
   * Traces whole the tree and logs it.
   */
  public function traceTree($root, $i) {
    if ($root->data != NULL) {
      if (is_array($root->data))
        foreach ($root->data as $d)
          rules_log("Rule %name at level %level",array('%name' => $d, '%level' => $i));
      else {
        rules_log("Condition %name at level %level",array('%name' => $root->data, '%level' => $i));
        $this->traceTree($root->left, $i + 1);
        $this->traceTree($root->right, $i + 1);
      }
    }
  }
}
