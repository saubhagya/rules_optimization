<?php
// $Id$

/**
 * @file
 * Rules Optimization class and class for decision tree.
 */

/**
 * A decision tree node.
 */
class RulesOptimizationTreeNode extends RulesPlugin implements RulesActionInterface {

  // Internal nodes contain conditions in $conditionData and for leaf nodes it is NULL.
  public $conditionData;
  // Leaf nodes contain actions in $leafActions array elsewhere this is empty array.
  public $leafActions;
  // If condition is evaluated to be TRUE then $trueTree subtree is followed otherwise $falseTree.
  public $trueTree;
  public $falseTree;

  function __construct() {
    // NULL and empty initialization.
    $this->conditionData = NULL;
    $this->leafActions = array();
    $this->trueTree = NULL;
    $this->falseTree = NULL;
  }

  /**
   * Overrides default evaluate method.
   */
  public function evaluate(RulesState $state) {
    // $this is passed as parameter to make recursion possible.
    if ($this->conditionData != NULL) {
      $this->evaluateCondition($this, $state);
    }
  }

  protected function evaluateCondition($node, $state) {
    if ($node->isLeaf()) {
      // It is a leaf evaluate all actions of leafActions array.
      foreach ($node->leafActions as $action) {
        $action->evaluate($state);
      }
    }
    else {
      if ($node->conditionData->evaluate($state)) {
        // Condition is evaluated TRUE, go to trueTree.
        $this->evaluateCondition($node->trueTree, $state);
      }
      else {
        // Condition is evaluated FALSE, go to flaseTree.
        $this->evaluateCondition($node->falseTree, $state);
      }
    }
  }
  
  public function integrityCheck() {
    if (isset($this->conditionData)) {
      $this->conditionData->integrityCheck();
      if ($this->trueTree != NULL) {
        $this->trueTree->integrityCheck();
      }
      if ($this->falseTree != NULL) {
        $this->falseTree->integrityCheck();
      }
    }
    else {
      foreach ($this->leafActions as $action) {
        $action->integrityCheck();
      }
    }
    return $this;
  }

  /**
   * @return
   *   TRUE if node is leaf node otherwise FALSE.
   */
  public function isLeaf() {
    return $this->trueTree == NULL && $this->falseTree == NULL ? TRUE : FALSE;
  }

  public function __sleep() {
    return array('conditionData', 'trueTree', 'falseTree', 'leafActions');
  }
}

/**
 * Class implementing optimization method.
 */
class RulesOptimization extends FacesExtender implements RulesOptimizationInterface {

  /**
   * Overrides the default optimization method.
   */
  public function optimize() {

    $tree = NULL;
    $conditions = array();
    $allCondition = array();
    $event = $this->getExtendable();

    foreach ($event as $rule) {
      if ($rule->integrityCheck() && $rule->conditions() != NULL) {
        // Convert conditions for insertion in decision tree.
        $convertedConditions = $this->convertRuleConditions((array) $rule->conditions());
        // Any element of $convertConditions give all conditions in rule.
        if (!empty($convertedConditions)) {
          $this->getAllCondition($this->arrayClone(end($convertedConditions)), $allCondition);
          // It would be easy to get that condition is of which rule.
          foreach ($convertedConditions as $key => $condition) {
            array_push($convertedConditions[$key], $rule);
          }
          $conditions = array_merge($conditions, $convertedConditions);
        }
      }
    }

    if (!empty($allCondition)) {
      $tree = $this->insertRuleConditions($conditions, $allCondition);
    }
    // Remove all the children of $event so that decision tree would be set as child of $event for optimization to trigger.
    $flag = 1;
    while ($flag) {
      $flag = 0;
      foreach ($event->getIterator() as $child) {
        $flag = 1;
        $child->delete($child);
      }
    }
    RulesLog::logger()->checkLog();
    // Make decision tree as the only child of $event.
    if ($tree != NULL) {
      $event->rule($tree->trueTree->integrityCheck());
    }
    else {
      $tree = new RulesOptimizationTreeNode;
      $event->rule($tree);
    }
  }

  /**
   * Converts the input rule conditions to make them suitable for insertion in decision tree.
   *
   * @param $condition
   *   Condition for preprocessing before insertion.
   *
   * @return
   *   Array of arrays where each array would be in AND form, if any one is evaluated to TRUE then action should be triggered.
   */
  protected function convertRuleConditions($conditions) {

    $convertedConditions = array($conditions);
    $flag = 1;
    while ($flag) {
      // While there is some change in $conditions, repeat conversion again.
      $this->convert($convertedConditions, $flag);
    }
    $this->removeFALSEConditions($convertedConditions);
    return $convertedConditions;
  }

  /**
   * Invoked by convertRuleConditions for actual processing.
   */
  protected function convert(&$conditions, &$flag) {

    $flag = 0;
    $auxConditions = $conditions;
    $conditionArrCount = 0;

    foreach ($auxConditions as $key => $conditionArr) {
      $conditionCount = 0;

      foreach ($conditionArr as $condition) {
        if ($condition instanceof RulesAND) {
          if (sizeof($condition->getIterator()) == 0) {
            // AND contains no condition, remove it from the array.
            array_splice($conditions[$key], $conditionCount, 1);
            $flag = 1;
            return;
          }
          // Else convert AND and place the returned array in place of AND.
          array_splice($conditions[$key], $conditionCount, 1, $this->convertAND($condition));
          $flag = 1;
          return;
        }
        elseif ($condition instanceof RulesOR) {
          if (sizeof($condition->getIterator()) == 0) {
            // OR contains no condition, remove it from the array.
            array_splice($conditions[$key], $conditionCount, 1);
            $flag = 1;
            return;
          }
          $convertedORArray = $this->convertOR($condition);
          // $convertedORArray is array of arrays, so it can't just replace OR like AND.
          $auxArr = array();
          // Put each array of $convertedORArray in place of OR.
          foreach ($convertedORArray as $arr) {
            $auxConditionArr = $conditions[$key];
            array_splice($auxConditionArr, $conditionCount, 1, $arr);
            array_push($auxArr, $auxConditionArr);
          }
          array_splice($conditions, $conditionArrCount, 1, $auxArr);
          $flag = 1;
          return;
        }
        $conditionCount++;
      }
      $conditionArrCount++;
    }
    $flag = 0;
  }

  /**
   * Converts RulesAND in the condition so that get the same logic in AND form. This is the case when AND is negated.
   *
   * @param $condition
   *   This is an instance of RulesAND and its children are related in AND form.
   *
   * @return
   *   Array containing conditions in AND form.
   *
   * @see RulesAND
   */
  protected function convertAND($condition) {
    // AND is negated, convert it into OR and change negation sign of all the children. Simple logic.
    if ($condition->isNegated()) {
      $newCondition = rules_or();
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $newCondition->condition($child);
      }
      return array($newCondition);
    }
    else {
      return $condition->getIterator();
    }
  }

  /**
   * Converts RulesOR in the condition so that get the same logic in AND form.
   *
   * @param $condition
   *   This is an instance of RulesOR and its children are related in OR form.
   *
   * @return
   *   Array of arrays containing conditions in AND form.
   *
   * @see RulesOR
   */
  protected function convertOR($condition) {
    if ($condition->isNegated()) {
      // OR is negated, convert it into AND and change negation sign of all the children. Simple logic.
      $newCondition = rules_and();
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $newCondition->condition($child);
      }
      // Return array of arrays to be as per the specification.
      return array(array($newCondition));
    }
    else {
      $newConditionArr = array();
      $array = array();
      $conditionCount = 0;

      foreach ($condition->getIterator() as $child) {
        $array[$conditionCount++] = $child;
      }
      // Get all the permutations except which have all negated conditions.
      $totPermutation = pow(2, $conditionCount) - 1;
      for ($count = 0; $count < $totPermutation; $count++) {
        $newCondition = $this->arrayClone($array);
        // Binary numbers would give all permutations.
        $binary = base_convert($count, 10, 2);
        $size = strlen($binary);
        for ($bitNo = $size - 1, $conditionNo = $conditionCount - 1; $bitNo >= 0; $bitNo--, $conditionNo--) {
          if ($binary[$bitNo]) {
            // Bit is set, change the sign of negation.
            $newCondition[$conditionNo]->isNegated()?$newCondition[$conditionNo]->negate(FALSE):$newCondition[$conditionNo]->negate(TRUE);
          }
          // Bit is zero, do nothing.
        }
        $newConditionArr[$count] = $newCondition;
      }
      return $newConditionArr;
    }
  }

  /**
   * Removes the rules which would give FALSE output in every case.
   * @param $convertedConditions
   *   Array of arrays where deeper arrays are conditions of a single rule in AND form.
   */
  protected function removeFALSEConditions(&$convertedConditions) {
    $auxConvertedConditions = array();
    foreach ($convertedConditions as $conditions) {
      array_push($auxConvertedConditions, $this->arrayClone($conditions));
    }
    // Condition array count which is to be removed.
    $count = 0;
    foreach ($auxConvertedConditions as $conditions) {
      $flag = 1;
      $auxConditions = array();
      foreach ($conditions as $condition) {
        array_push($auxConditions, $condition);
      }
      $size = sizeof($auxConditions);
      for ($i = 0; $i < $size && $flag; $i++) {
        for ($j = $i + 1; $j < $size && $flag; $j++) {
          if ($this->isEqualType($auxConditions[$i], $auxConditions[$j])) {
            // If value part is different then this would result FALSE in every condition.
            $flag = 0;
            array_splice($convertedConditions, $count, 1);
            $count--;
          }
        }
      }
      $count++;
    }
  }
  
  /**
   * Compares two conditions to check if they are of equal type or not.
   * TODO: Check that this function work in every situation.
   */
  public function isEqualType($conditionFirst, $conditionSecond) {
    if ($conditionFirst->getElementName() == 'data_is' && $conditionSecond->getElementName() == 'data_is' && $conditionFirst->isNegated() == $conditionSecond->isNegated()) {
      $settingsFirst = $conditionFirst->settings;
      $settingsSecond = $conditionSecond->settings;
      if (isset($settingsFirst['op']) && isset($settingsSecond['op']) && $settingsFirst['op'] == '==' && $settingsSecond['op'] == '==' && $settingsFirst['data:select'] == $settingsSecond['data:select']) {
        if (isset($settingsFirst['value:select']) && isset($settingsSecond['value:select']) && $settingsFirst['value:select'] != $settingsSecond['value:select']) {
          return TRUE;
        }
      }
    }
    return FALSE;
  }
  
  /**
   * Inserts the converted conditions and corresponding rule in the decision tree.
   *
   * @param $conditions
   *   An array containing last element as rule and remaining array is all the conditions of rule in AND form.
   * @param $allCondition
   *   All different conditions in the rule set or event set.
   *
   * @see getAllCondition()
   */
  protected function insertRuleConditions($conditions, $allCondition) {

    // Root of the decision tree, which would be empty and actual tree would be trueTree of this node.
    $root = new RulesOptimizationTreeNode;
    // A dummy node which is the trueTree of root.
    $dummy = new RulesOptimizationTreeNode;
    $root->trueTree = $dummy;

    foreach ($conditions as $conditionArr) {
      // Get the rule.
      $rule = end($conditionArr);
      // Remaining array have conditions.
      array_splice($conditionArr, sizeof($conditionArr) - 1);
      // First arrange the $conditionArr for insertion in decision tree.
      $this->sortConditionArr($conditionArr, $allCondition);
      // Insert the sorted $conditionArr in decision tree.
      $this->insert($root, $conditionArr, $allCondition, $rule);
    }
    $this->traceTree($root->trueTree, 0);
    return $root;
  }

  /**
   * Sort the $conditionArr according the $allCondition array. After sorting $conditionArr would have 
   * same keys as that of $allCondition array and values would be the direction.
   *
   * @param $conditionArr
   *   Array of conditions which is to be sorted.
   * @param $allCondition
   *   Array of all the different conditions in rule set or event set.
   *
   * @see getAllCondition()
   */
  protected function sortConditionArr(&$conditionArr, $allCondition) {

    // Temprory array which would be reassigned as $conditionArr.
    $auxConditionArr = array();
    $auxAllCondition = $this->arrayClone($allCondition);
    $size = sizeof($allCondition);

    // Array of flags initialized to all zeros. If conditions match corresponding flag would be set.
    for ($count = 0; $count < $size; $count++) {
      $flag[$count] = 0;
    }
    foreach ($conditionArr as $c) {
      for ($count = 0; $count < $size; $count++) {
        if (!$flag[$count] && $allCondition[$count]->getElementName() == $c->getElementName() && $allCondition[$count]->settings == $c->settings) {
          // Conditions matched and flag was zero. Set the flag.
          $flag[$count] = 1;
          // If condition is negated then true branch would be taken, otherwise false.
          $auxConditionArr[$count] = $c->isNegated() ? 'FALSE' : 'TRUE';
          // Search equal type of condition in upper levels of tree to put rest of conditions in false tree of that.
          if ($c->getElementName() == 'data_is') {
            for ($auxCount = 0; $auxCount < $count; $auxCount++) {
              if (!$flag[$auxCount] && $this->isEqualType($c, $allCondition[$auxCount])) {
                $flag[$auxCount] = 1;
                $auxConditionArr[$auxCount] = 'EQUALTYPE';
              }
            }
          }
          break;
        }
      }
    }

    // All conditions in $allCondition that were not matched with any condition in $conditionArr, set value BOTH.
    for ($count = 0; $count < $size; $count++) {
      if (!$flag[$count]) {
        $auxConditionArr[$count] = 'BOTH';
      }
    }
    $conditionArr = $auxConditionArr;
  }

  /**
   * Invoked by insertRuleConditions to insert individual rule conditions in the decision tree.
   *
   * @param $root
   *   Root of the decision tree in which conditions would be inserted.
   * @param $conditions
   *   Array of conditions which are referenced by $allConditions.
   * @param $allCondition
   *   Array of all the different conditions in rule set or event set.
   * @param $rule
   *   Rule which would be fired if $conditions is evaluated to be TRUE.
   *
   * @see getAllCondition()
   * @see sortConditionArr()
   */
  protected function insert(&$root, $conditions, $allCondition, $rule) {

    /**
     * An array of arrays. Deeper arrays contain two elements, first is the direction and second is the last 
     * node in decision tree whose direction side next node would be inserted.
     *
     * @see sortConditionArr()
     */
    $prevArr = array(array(0 => 'TRUE', 1 => $root));
    $arrSize = sizeof($allCondition);

    for ($key = 0; $key < $arrSize; $key++) {
      $condition = $allCondition[$key];
      $direction = $conditions[$key];
      // This array would be created in this pass, which would be $prevArr in next pass.
      $auxArr = array();

      foreach ($prevArr as $arr) {
        $prevDirection = $arr[0];
        $prevNode = $arr[1];
        // Node where $conditio is to be inserted.
        $node = $prevDirection == 'TRUE' ? $prevNode->trueTree : $prevNode->falseTree;

        // If node is a leaf or $condition and condition of $node doesn't match then we need new node for condition to be inserted.
        if ($node->isLeaf() || $condition->getElementName() != $node->conditionData->getElementName() || $condition->settings != $node->conditionData->settings) {
          // If direction is BOTH that means it doesn't effect if this condition is true or false. Checking this makes the tree size smaller.
          if ($direction != 'BOTH' && $direction != 'EQUALTYPE') {
            $newNode = new RulesOptimizationTreeNode;
            $newNode->conditionData = $condition;
            $newNode->trueTree = $node;
            $newNode->falseTree = $this->treeClone($node);;

            if ($prevDirection == 'TRUE') {
              $prevNode->trueTree = $newNode;
            }
            else {
              $prevNode->falseTree = $newNode;
            }
            // Append the newly created node and $direction in $auxArr.
            array_push($auxArr, array(0 => $direction, 1 => $newNode));
          }
          else {
            // Direction is BOTH, so the $prevDirection and $prevNode need to be preserved.
            array_push($auxArr, array(0 => $prevDirection, 1 => $prevNode));
          }
        }
        else {
          // It is a leaf node or $condition and condition of $node matched. So tree can proceed from current node.
          if ($direction == 'BOTH') {
            // Next condition would be inserted in both trueTree and flaseTree of the current node.
            array_push($auxArr, array(0 => 'TRUE', 1 => $node), array(0 => 'FALSE', 1 => $node));
          }
          elseif ($direction == 'TRUE') {
            array_push($auxArr, array(0 => 'TRUE', 1 => $node));
          }
          else {
          	// It's EQUALTYPE or FALSE.
            array_push($auxArr, array(0 => 'FALSE', 1 => $node));
          }
        }
      }
      $size = sizeof($auxArr);
      // Copy $auxArr to $prevArr for next iteration.
      for ($count = 0; $count < $size; $count++) {
        $prevArr[$count] = $auxArr[$count];
      }
    }
    foreach ($prevArr as $arr) {
      // All conditions are added in decision tree, now add the actions to all the leaves accessible by last condition node.
      $node = $arr[0] == 'TRUE' ? $arr[1]->trueTree : $arr[1]->falseTree;
      $this->addRule($node, $rule);
    }
  }

  /**
   * Recursively goes through the tree and copy all the properties.
   *
   * @param $tree
   *   Node, whose true and false subtrees and leaves to be copied.
   *
   * @return
   *   Copy of the $tree.
   */
  public function treeClone($tree) {

    $root = new RulesOptimizationTreeNode;
    $root->conditionData = $tree->conditionData;

    if ($tree->isLeaf()) {
      // It is a leaf node, contains array of actions.
      $root->leafActions = $this->arrayClone($tree->leafActions);
    }
    else {
      // Recursively build the tree.
      if ($tree->trueTree != NULL) {
        $root->trueTree = $this->treeClone($tree->trueTree);
      }
      if ($tree->falseTree != NULL) {
        $root->falseTree = $this->treeClone($tree->falseTree);
      }
    }
    return $root;
  }

  /**
   * Converts $allCondition such that if any condition that is in $conditionArr and not in $allCondition it is appended to $allCondition.
   * All conditions in $allCondition need to be non negated.
   *
   * @param $conditionArr
   *   Array of conditions, which is to be checked for new possible conditions that are not in $allCondition.
   * @param $allCondition
   *   Array containing all the different conditions in decision tree (i.e. maximum set of conditions).
   */
  protected function getAllCondition($conditionArr, &$allCondition) {

    $size = sizeof($allCondition);
    $nonNegatedConditions = array();

    // Converts all the conditions of $conditionArr to non negated for comparision.
    foreach ($conditionArr as $condition) {
      array_push($nonNegatedConditions, $condition->isNegated()?$condition->negate(FALSE):$condition);
    }
    // An array of flags initialized all zeros. If there is a match flag would be set.
    for ($count = 0; $count < $size; $count++) {
      $flag[$count] = 0;
    }
    foreach ($nonNegatedConditions as $condition) {
      $found = 0;
      for ($count = 0; $count < $size; $count++) {
        // Compares conditions from $conditionArr and $allCondition if $flag is zero.
        if ($flag[$count] == 0 && $allCondition[$count]->getElementName() == $condition->getElementName() && $allCondition[$count]->settings == $condition->settings) {
          $flag[$count] = 1;
          $found = 1;
          break;
        }
      }
      if (!$found) {
        // No match found: append $condition to $allCondition.
        array_push($allCondition, $condition);
      }
    }
  }

  /**
   * @param $array
   *   Array to be copied.
   *
   * @return
   *   The deep copy of the $array.
   */
  public function arrayClone($array) {

    $return = array();
    $keys = array_keys($array);
    $values = array_values($array);

    for ($count = 0; $count < count($keys); $count++) {
      if (is_object($values[$count])) {
        $return[$keys[$count]] = clone $values[$count];
      }
      elseif (is_array($values[$count])) {
        $return[$keys[$count]] = arrayClone($values[$count]);
      }
      else {
        $return[$keys[$count]] = $values[$count];
      }
    }
    return $return;
  }

  /**
   * Add the actions at the leaves accessible by input node.
   *
   * @param $rule
   *   The rule, whose actions are to be inserted.
   */
  protected function addRule(&$node, $rule) {
    if ($node->isLeaf()) {
      // It is a leaf node append all the actions in the leafActions.
      foreach ($rule->actions() as $action) {
        array_push($node->leafActions, $action);
      }
    }
    else {
      // Recursively add the actions in trueTree and falseTree of current node.
      $this->addRule($node->trueTree, $rule);
      $this->addRule($node->falseTree, $rule);
    }
  }

  /**
   * Recursively traces whole the tree and logs it.
   *
   * @param $level
   *   Level of the $root in tree.
   */
  public function traceTree($node, $level) {
    if ($node->isLeaf()) {
      foreach ($node->leafActions as $action) {
        rules_log("Action %name at level %level", array('%name' => $action, '%level' => $level));
      }
    }
    else {
      rules_log("Condition %name at level %level", array('%name' => $node->conditionData, '%level' => $level));
      $this->traceTree($node->trueTree, $level + 1);
      $this->traceTree($node->falseTree, $level + 1);
    }
  }
}
