<?php
// $Id$

/**
 * @file Rules Optimization class and class for decision tree.
 */

/**
 * A decision tree node.
 */
class TreeNode extends RulesPlugin implements RulesActionInterface {

  public $data;
  public $isLeaf;
  public $children;

  function __construct() {
    $this->data = NULL;
    $this->isLeaf = FALSE;
    $this->children = array('left' => NULL, 'right' => NULL);
  }

  public function evaluate(RulesState $state) {
    $this->evaluateCondition ($this, $state);
  }

  public function evaluateCondition($node, $state) {
    if ($node->isLeaf) {
      foreach ($node->children as $action) {
        $action->evaluate($state);
      }
    }
    else {
      if ($node->data->evaluate($state)) {
        $this->evaluateCondition($node->children['left'], $state);
      }
      else {
        $this->evaluateCondition($node->children['right'], $state);
      }
    }
  }

  public function __sleep() {
    return array('data', 'isLeaf', 'children');
  }
}

/**
 * Class implementing optimization method.
 */
class RulesOptimization extends FacesExtender implements RulesOptimizationInterface {

  /**
   * Implementation of optimize method.
   */
  public function optimize() {

    $tree = new TreeNode;
    $conditions = array();
    $allCondition = array();
    $event = $this->getExtendable();
    $rules = $event->getIterator();

    foreach ($rules as $rule) {
      $newConditions = rules_and();
      if ($rule->conditions() != NULL) {
        foreach ($rule->conditions() as $condition) {
          $newConditions->condition($condition);
        }
        $newConditions = $this->convertRuleConditions($newConditions);
        $this->getAllCondition($this->arrayCopy($newConditions[0]), $allCondition);
        foreach ($newConditions as $key => $nc) {
          array_push($newConditions[$key], $rule);
        }
        $conditions = array_merge($conditions, $newConditions);
      }
    }

    if (!empty($allCondition)) {
      $tree = $this->insertRuleConditions($conditions, $allCondition);
    }

    $flag = 1;
    while ($flag) {
      $flag = 0;
      foreach ($event->getIterator() as $child) {
        $flag = 1;
        $child->delete($child);
      }
    }
    RulesLog::logger()->checkLog();
    $event->rule($tree->children['left']);
  }

  /**
   * Conerts the input rule conditions to make them suitable for insertion in decision tree.
   */
  public function convertRuleConditions($condition) {

    $conditions = array(array($condition));
    $flag = 1;
    while ($flag) {
      $this->convert($conditions, $flag);
    }
    return $conditions;
  }

  /**
   * Invoked by convertRuleConditions for actual processing.
   */
  public function convert(&$conditions, &$flag) {

    $flag = 0;
    $auxConditions = $conditions;
    $conditionArrCount = 0;

    foreach ($auxConditions as $key => $conditionArr) {
      $conditionCount = 0;
      foreach ($conditionArr as $condition) {

        if ($condition instanceof RulesAND) {
          if (sizeof($condition->getIterator()) == 0) {
            array_splice($conditions[$key], $conditionCount, 1);
            $flag = 1;
            return;
          }
          array_splice($conditions[$key], $conditionCount, 1, $this->convertAND($condition));
          $flag = 1;
          return;
        }
        elseif ($condition instanceof RulesOR) {
          if (sizeof($condition->getIterator()) == 0) {
            array_splice($conditions[$key], $conditionCount, 1);
            $flag = 1;
            return;
          }
          $convertedORArray = $this->convertOR($condition);
          $auxArr = array();
          foreach ($convertedORArray as $arr) {
            $auxConditionArr = $conditions[$key];
            array_splice($auxConditionArr, $conditionCount, 1, $arr);
            array_push($auxArr, $auxConditionArr);
          }
          array_splice($conditions, $conditionArrCount, 1, $auxArr);
          $flag = 1;
          return;
        }
        $conditionCount++;
      }
      $conditionArrCount++;
    }
    $flag = 0;
  }

  /**
   * Converts the AND in the condition.
   */
  public function convertAND($condition) {
    if ($condition->isNegated()) {
      $newCondition = rules_or();
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $newCondition->condition($child);
      }
      return array($newCondition);
    }
    else {
      return $condition->getIterator();
    }
  }

  /**
   * Converts RulesOR in the condition.
   * @return
   *   Array of arrays containing conditions in OR form.
   */
  public function convertOR($condition) {
    if ($condition->isNegated()) {
      $newCondition = rules_and();
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $newCondition->condition($child);
      }
      return array(array($newCondition));
    }
    else {
      $newConditionArr = array();
      $array = array();
      $conditionCount = 0;
      foreach ($condition->getIterator() as $child) {
        $child->isNegated()?$child->negate(FALSE):$child->negate(TRUE);
        $array[$conditionCount++] = $child;
      }
      for ($count = 0; $count < $conditionCount; $count++) {
        $newConditionArr[$count] = $this->arrayCopy($array);
        $newConditionArr[$count][$count]->isNegated()?$newConditionArr[$count][$count]->negate(FALSE):$newConditionArr[$count][$count]->negate(TRUE);
      }
    }
    return $newConditionArr;
  }

  /**
   * Inserts the converted conditions and corresponding rule in the decision tree.
   */
  public function insertRuleConditions($conditions, $allCondition) {

    $root = new TreeNode;
    $dummy = new TreeNode;
    $dummy->isLeaf = TRUE;
    $dummy->children = array();
    $root->children['left'] = $dummy;

    foreach ($conditions as $conditionArr) {
      $rule = end($conditionArr);
      array_splice($conditionArr, sizeof($conditionArr) - 1);
      $this->sortConditionArr($conditionArr, $allCondition);
      $this->insert($root, $conditionArr, $allCondition, $rule);
    }
    $this->traceTree($root->children['left'], 0);
    return $root;
  }

  /**
   * Sort the input condition array as the allCondition array.
   */
  public function sortConditionArr(&$conditionArr, $allCondition) {

    $auxConditionArr = array();
    $size = sizeof($allCondition);

    for ($count = 0; $count < $size; $count++) {
      $flag[$count] = 0;
    }
    for ($count = 0; $count < $size; $count++) {
      if ($flag[$count] == 0) {
        foreach ($conditionArr as $c) {
          if ($allCondition[$count]->getElementName() == $c->getElementName()) {
            $flag[$count] = 1;
            $auxConditionArr[$count] = $c->isNegated()?'RIGHT':'LEFT';
            break;
          }
        }
      }
    }

    for ($count = 0; $count < $size; $count++) {
      if (!$flag[$count]) {
        $auxConditionArr[$count] = 'BOTH';
      }
    }
    $conditionArr = $auxConditionArr;
  }

  /**
   * Invoked by insertRuleConditions to insert individual rule conditions.
   */
  public function insert(&$root, $conditions, $allCondition, $rule) {

    $prevArr = array(array(0 => 'LEFT', 1 => $root));
    $arrSize = sizeof($allCondition);

    for ($key = 0; $key < $arrSize; $key++) {
      $condition = $allCondition[$key];
      $direction = $conditions[$key];
      $auxArr = array();

      foreach ($prevArr as $arr) {
        $prevDirection = $arr[0];
        $prevNode = $arr[1];
        $node = $prevDirection == 'LEFT'?$prevNode->children['left']:$prevNode->children['right'];

        if ($node->isLeaf == TRUE || $condition->getElementName() != $node->data->getElementName()) {
          if ($direction != 'BOTH') {
            $newNode = new TreeNode;
            $newNode->data = $condition;
            $newNode->children['left'] = $node;
            $newNode->children['right'] = $this->treeCopy($node);;
            if ($prevDirection == 'LEFT') {
              $prevNode->children['left'] = $newNode;
            }
            else {
              $prevNode->children['right'] = $newNode;
            }
            array_push($auxArr, array(0 => $direction, 1 => $newNode));
          }
          else {
            array_push($auxArr, array(0 => $prevDirection, 1 => $prevNode));
          }
        }
        else {
          if ($direction == 'BOTH') {
            array_push($auxArr, array(0 => 'LEFT', 1 => $node), array(0 => 'RIGHT', 1 => $node));
          }
          elseif ($direction == 'LEFT') {
            array_push($auxArr, array(0 => 'LEFT', 1 => $node));
          }
          else {
            array_push($auxArr, array(0 => 'RIGHT', 1 => $node));
          }
        }
      }
      $size = sizeof($auxArr);
      for ($count = 0; $count < $size; $count++)
        $prevArr[$count] = $auxArr[$count];
    }
    foreach ($prevArr as $arr) {
      $node = $arr[0] == 'LEFT'?$arr[1]->children['left']:$arr[1]->children['right'];
      $this->addRule($node, $rule);
    }
  }

  /**
   * Returns the exact copy of the input tree.
   */
  public function treeCopy($tree) {

    $root = new TreeNode;
    $root->data = $tree->data;
    $root->isLeaf = $tree->isLeaf;

    if ($root->isLeaf) {
      $root->children = array();
      foreach ($tree->children as $child) {
        array_push($root->children, $child);
      }
    }
    else {
      if ($tree->children['left'] != NULL) {
        $root->children['left'] = $this->treeCopy($tree->children['left']);
      }
      if ($tree->children['right'] != NULL) {
        $root->children['right'] = $this->treeCopy($tree->children['right']);
      }
    }
    return $root;
  }

  /**
   * Append the new conditions of input temp to allCondition.
   */
  public function getAllCondition($conditionArr, &$allCondition) {

    $size = sizeof($allCondition);
    $nonNegatedConditions = array();

    foreach ($conditionArr as $condition) {
      array_push($nonNegatedConditions, $condition->isNegated()?$condition->negate(FALSE):$condition);
    }
    for ($count = 0; $count < $size; $count++) {
      $flag[$count] = 0;
    }
    foreach ($nonNegatedConditions as $condition) {
      $found = 0;
      for ($count = 0; $count < $size; $count++) {
        if ($flag[$count] == 0 && $allCondition[$count]->getElementName() == $condition->getElementName()) {
          $flag[$count] = 1;
          $found = 1;
        }
      }
      if (!$found) {
        array_push($allCondition, $condition);
      }
    }
    return $allCondition;
  }

  /**
   * Return the copy of the input array.
   */
  public function arrayCopy($array) {

    $return = array();
    $keys = array_keys($array);
    $values = array_values($array);

    for ($count = 0; $count < count($keys); $count++) {
      if (is_object($values[$count])) {
        $return[$keys[$count]] = clone $values[$count];
      }
      elseif (is_array($values[$count])) {
        $return[$keys[$count]] = arrayCopy($values[$count]);
      }
      else {
        $return[$keys[$count]] = $values[$count];
      }
    }
    return $return;
  }

  /**
   * Add the input rule at the leaves accessible by input node.
   */
  public function addRule(&$node, $rule) {
    if ($node->isLeaf) {
      foreach ($rule->actions() as $action) {
        array_push($node->children, $action);
      }
    }
    else {
      $this->addRule($node->children['left'], $rule);
      $this->addRule($node->children['right'], $rule);
    }
  }

  /**
   * Traces whole the tree and logs it.
   */
  public function traceTree($root, $level) {
    if ($root->isLeaf) {
      foreach ($root->children as $action) {
        rules_log("Action %name at level %level", array('%name' => $action, '%level' => $level));
      }
    }
    else {
      rules_log("Condition %name at level %level", array('%name' => $root->data, '%level' => $level));
      $this->traceTree($root->children['left'], $level + 1);
      $this->traceTree($root->children['right'], $level + 1);
    }
  }
}
